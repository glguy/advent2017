{-# Language RoleAnnotations, DataKinds, KindSignatures #-}
{-|
Module      : Advent.Permutation
Description : Composable permutations
Copyright   : (c) Eric Mertens, 2017
License     : ISC
Maintainer  : emertens@gmail.com
-}
module Advent.Permutation
  ( Permutation
  , runPermutation
  , mkPermutation
  , swap
  , rotateRight
  , rotateLeft
  , invert
  , isValid
  , size
  , backwards
  ) where

import Data.List
import Data.List.NonEmpty (NonEmpty((:|)))
import Data.Function (fix)
import Data.Semigroup
import GHC.TypeLits
import qualified Data.Vector.Unboxed as V

type role Permutation nominal

-- | Permutations of @n@ elements
newtype Permutation (n :: Nat) = P (V.Vector Int)
  deriving (Eq, Ord, Read, Show)

runPermutation :: (Int -> a) -> Permutation n -> [a]
runPermutation f (P v) = f <$> V.toList v

-- | Size of the list of elements permuted.
size :: Permutation n -> Int
size (P v) = V.length v

-- | Validate a permutation. A valid permutation will map each element in the input
-- to a unique element in the output.
isValid :: Permutation n -> Bool
isValid (P p) = V.and (V.accumulate_ (\_ new -> new) (V.replicate n False) p (V.replicate n True))
  where
    n = V.length p

-- | Helper function for making the size of a requested permutation available
-- while building the permutation.
withSize :: KnownNat n => (Int -> Permutation n) -> Permutation n
withSize f = fix (f . fromIntegral . natVal)

-- | Given a function mapping incoming indices to outgoing ones, construct
-- a new permutation value.
mkPermutation :: KnownNat n => (Int -> Int) -> Permutation n
mkPermutation f = withSize $ \n -> P $ V.generate n $ \i -> f i `mod` n

-- | Permutation generated by swapping the elements at a pair of indices.
swap :: KnownNat n => Int -> Int -> Permutation n
swap x y = withSize $ \n ->
  let x' = x`mod`n -- not evaluated when n == 0
      y' = y`mod`n
  in mkPermutation $ \i -> if i == x' then y' else if i == y' then x' else i

-- | Permutation generated by rotating all the elements to the right.
rotateRight :: KnownNat n => Int -> Permutation n
rotateRight = rotateLeft . negate

-- | Permutation generated by rotating all the elements to the left.
rotateLeft :: KnownNat n => Int -> Permutation n
rotateLeft n = mkPermutation $ \i -> i+n

-- | Permutation generated by inverting another permutation.
invert :: Permutation n -> Permutation n
invert (P v) = P (V.accumulate_ (\_ new -> new) initial v iota)
  where
    n       = V.length v
    initial = V.replicate n 0 -- 0 is arbitrary, should all be overwritten
    iota    = V.generate n id

-- | Permutation generated by reversing the order of the elements.
backwards :: KnownNat n => Permutation n
backwards = mkPermutation $ \i -> -i-1

instance Semigroup (Permutation n) where
  P x <> P y        = P (V.backpermute x y)
  sconcat (x :| xs) = foldl' (<>) x xs

instance KnownNat n => Monoid (Permutation n) where
  mempty           = mkPermutation id
  mappend          = (<>)
  mconcat []       = mempty
  mconcat (x : xs) = sconcat (x :| xs)
